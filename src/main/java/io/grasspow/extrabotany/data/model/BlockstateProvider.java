package io.grasspow.extrabotany.data.model;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import io.grasspow.extrabotany.api.ExtraBotanyAPI;
import io.grasspow.extrabotany.common.libs.LibMisc;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.data.CachedOutput;
import net.minecraft.data.DataProvider;
import net.minecraft.data.PackOutput;
import net.minecraft.data.models.blockstates.BlockStateGenerator;
import net.minecraft.data.models.model.ModelTemplate;
import net.minecraft.data.models.model.TextureMapping;
import net.minecraft.data.models.model.TextureSlot;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.level.block.Block;
import org.slf4j.Logger;
import vazkii.botania.common.block.BotaniaFlowerBlock;
import vazkii.botania.common.block.decor.BotaniaMushroomBlock;
import vazkii.botania.common.block.decor.FloatingFlowerBlock;
import vazkii.botania.xplat.XplatAbstractions;

import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static io.grasspow.extrabotany.common.libs.ResourceLocationHelper.resId;
import static net.minecraft.data.models.model.ModelLocationUtils.getModelLocation;

public class BlockstateProvider extends vazkii.botania.data.BlockstateProvider {
    public BlockstateProvider(PackOutput packOutput) {
        super(packOutput);
    }

    @Override
    public String getName() {
        return "ExtraBotany Blockstates";
    }

    @Override
    protected Logger getLogger() {
        return ExtraBotanyAPI.logger;
    }


    Predicate<Block> flowers = b -> XplatAbstractions.INSTANCE.isSpecialFlowerBlock(b)
            || b instanceof BotaniaMushroomBlock
            || b instanceof BotaniaFlowerBlock;

    @Override
    public CompletableFuture<?> run(CachedOutput cache) {
        try {
            registerStatesAndModels();
        } catch (Exception e) {
            getLogger().error("Error registering states and models", e);
        }

        PackOutput.PathProvider blockstatePathProvider = packOutput.createPathProvider(PackOutput.Target.RESOURCE_PACK, "blockstates");
        PackOutput.PathProvider modelPathProvider = packOutput.createPathProvider(PackOutput.Target.RESOURCE_PACK, "models");
        List<CompletableFuture<?>> output = new ArrayList<>();

        for (BlockStateGenerator state : blockstates) {
            ResourceLocation id = BuiltInRegistries.BLOCK.getKey(state.getBlock());
            Path path = blockstatePathProvider.json(id);
            output.add(DataProvider.saveStable(cache, state.get(), path));
        }

        for (Map.Entry<ResourceLocation, Supplier<JsonElement>> e : models.entrySet()) {
            ResourceLocation modelId = e.getKey();
            Path path = modelPathProvider.json(modelId);
            JsonObject jsonObject = e.getValue().get().getAsJsonObject();
            if (jsonObject.get("parent").toString().contains("block/shapes/cross")) {
                jsonObject.add("render_type", new JsonPrimitive("cutout"));
            }
            output.add(DataProvider.saveStable(cache, jsonObject, path));
        }
        return CompletableFuture.allOf(output.toArray(CompletableFuture[]::new));
    }

    @Override
    protected void registerStatesAndModels() {
        Set<Block> remainingBlocks = BuiltInRegistries.BLOCK.stream()
                .filter(b -> LibMisc.MOD_ID.equals(BuiltInRegistries.BLOCK.getKey(b).getNamespace()))
                .collect(Collectors.toSet());

        //flower
        takeAll(remainingBlocks, b -> b instanceof FloatingFlowerBlock).forEach(b -> {
            // Models generated by FloatingFlowerModelProvider
            singleVariantBlockState(b, getModelLocation(b));
        });
        ModelTemplate crossTemplate = new ModelTemplate(Optional.of(resId("block/shapes/cross")), Optional.empty(), TextureSlot.CROSS);
//        ModelTemplate renderTypeTemplate = new ModelTemplate(Optional.of())
        takeAll(remainingBlocks, flowers).forEach(b -> singleVariantBlockState(b, crossTemplate.create(b, TextureMapping.cross(b), this.modelOutput)));

    }
}
